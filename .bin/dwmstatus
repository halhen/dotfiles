#!/usr/bin/env python

import re
import os
import subprocess
from time import strftime, localtime, sleep

re_bat = re.compile('(Charging|Discharging|Full), (\d+)%')
re_bat_discharge = re.compile('(\d\d):(\d\d):\d\d remaining')
re_temp = re.compile('(\d+(\.\d)?) degrees')

re_moc_title = re.compile('Title: (.*)')
re_moc_artist = re.compile('Artist: (.*)')
re_moc_songtitle = re.compile('SongTitle: (.*)')
re_moc_file = re.compile('File: (.*)')

separator = ' | '

def time_str():
    return strftime('%H:%M')

def music_str():
    try:
        retcode = subprocess.call(['pidof', 'mocp'], stdout=subprocess.PIPE)
        # Query only if mocp is alive, otherwise it starts the server
        if retcode == 0:
            title = artist = songtitle = filename = ''
            mocstr='\n'.join(os.popen('/usr/bin/mocp -i'))

            m = re_moc_title.search(mocstr)
            if m:
                title = m.group(1)
            m = re_moc_artist.search(mocstr)
            if m:
                artist = m.group(1)
            m = re_moc_songtitle.search(mocstr)
            if m:
                songtitle = m.group(1)
            m = re_moc_file.search(mocstr)
            if m:
                filename = m.group(1)

            if artist and title:
                return '%s - %s' % (artist, title)
            elif songtitle:
                return songtitle
            elif title:
                return title
            elif artist:
                return artist
            elif filename:
                return filename
    except:
        pass
    return ''

def mail_str():
    try:
        numnew = len(os.listdir('/home/henrik/.mail/INBOX/new'))
        if numnew > 0:
            return '%d new mail%s' % (numnew, numnew > 1 and 's' or '')
    except:
        pass
    return ''

def acpi_str():
    acpilines = list(os.popen('acpi -V').readlines())
    bat_match = re_bat.search(acpilines[0]) 
    temp_match = re_temp.search(acpilines[3])

    bat_str = temp_str = ''

    if not bat_match:
        bat_str = ' ' * 4
    else:
        status = bat_match.group(1)
        load = int(bat_match.group(2))

        if status == 'Discharging':
            bat_discharge_match = re_bat_discharge.search(acpilines[0])
            bat_str = '%dh%s' % (int(bat_discharge_match.group(1)), bat_discharge_match.group(2))
        else:
            if load > 98:
                bat_str = 'FULL'
            else:
                bat_str = '+%2d%%' % (load)

    if not temp_match:
        temp_str = ' ' * 5
    else:
        temp_str = temp_match.group(1) + 'C'

    return temp_str + separator + bat_str

def setstatus(text):
    subprocess.call(['xsetroot', '-name', text])
    
if __name__ == '__main__':
    import optparse

    o = optparse.OptionParser(usage="%prog [options]", 
           description="Update dwm status bar. Use -l to keep %prog alive to regularly keep updating.")
    o.add_option('-l', '--keep-alive', dest='loop', action='store_true', 
                default=False, help='Keep updating regularly')

    (options, args) = o.parse_args()
    loop = options.loop

    while True:
        statusstr = separator.join(s for s in (mail_str(), music_str(), acpi_str(), time_str()) if s)
        setstatus(statusstr)
        if not loop:
            break
        # Update every HH:MM:00
        sleep(60 - localtime().tm_sec)
